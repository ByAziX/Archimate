/*
 * Statistics
 * 
 * Show some stats in a message alert box
 * 
 * (c) 2024 Azix
 * 
 * This work is licensed under the HUMANS Licence described below.
 * 
 * The HUMANS (Help Us Make Archi Noteworthy & Sustainable) licence goal is to bring happiness
 * to both Archi users and developers. This means that we would like users of
 * jArchi to donate something and get this useful script as a gift in return (and feel great!).
 *
 * The only restrictions that apply are:
 *  - You can't redistribute this script.
 *  - You can't use this script for commercial purposes unless you obtained it from the official Archi distribution channels.
 * 
 */
const serviceMap = {
    '443': 'HTTPS',
    '80': 'HTTP',
    '22': 'SSH',
    '21': 'FTP',
    '23': 'Telnet',
    '25': 'SMTP',
    '110': 'POP3',
    '143': 'IMAP',
    '389': 'LDAP',
    '636': 'LDAPS',
    '53': 'DNS',
    '123': 'NTP',
    '161': 'SNMP',
  };

console.show();
console.clear();
console.log("----------GET OBJECT NODE FROM MODEL-!!!!!!!!!!!!!!!!!!!!------------");
var nodes = $("node");
//console.log(nodes);

console.log("----------GET VIEW-!!!!!!!!!!!!!!!!!!!!------------");
var view = $(".5-Prod").first(); // Get view from its name (pick the first one if multiple views share the same name)
console.log($(view).filter("name")) // Get the name of the view
var flowRelationship = $(view).find("flow-relationship"); // Build a collection containing the view, and then get all flow-relationship in this view.
var compositionRelationship = $(view).find("composition-relationship"); // Build a collection containing the composition-relationship, and then get all flow-relationship in this view.
var aggregationRelationship = $(view).find("aggregation-relationship"); // Build a collection containing the aggregation-relationship, and then get all flow-relationship in this view.
var defaultFileName = model.name ? model.name + ".xlsx" : "Exported Model.xlsx"; // Default file name
var exportFile = window.promptSaveFile({ title: "Export to Excel", filterExtensions: [ "*.xlsx" ], fileName: defaultFileName } );
let currentRow = 1, currentRowObject = 1, currentRowPort = 1;
let uniqueObject = new Map();
let uniquePorts = new Set(); // Initialise un Set vide pour collecter les ports uniques
if(exportFile == null) {
    console.log("> Export cancelled");
    exit();
}
console.log("> Starting Excel Export");
// Load MyExcel and JSZip JS files
load(__DIR__ + "lib/jszip-101.js");
load(__DIR__ + "lib/myexcel.js");
// Create a new Excel file with a default font and colour
var excel = $JExcel.new("Calibri 12 #333333");
var sheet2 = excel.addSheet('Objects');
var sheet3 = excel.addSheet('Ports');
var sheet4 = excel.addSheet('FW Rules');
var sheet5 = excel.addSheet('FW Objects');
var sheet6 = excel.addSheet('FW Ports');

var formatHeader = excel.addStyle({ border: "none,none,none,thin #333333", font: "Calibri 12 #1B2A41 B", fill: "#f3f3f3" });
function setHeaders() {
    const headers = {
        rules: ["Demandeur CDP", "Demandeur Archi", "Type flux", "Prod/HP", "Env.", "In/Out", "Description", "Source Nom", "Source IP", "Destination Nom", "Destination IP", "Proto Nom", "Proto/Port", "Avis SSI", "Commentaire SSI", "Etat", "ID (Nom) de la Règle", "Date implémentation /Révision", "Opérateur"],
        objects: ["Group Name", "Object Name", "IP", "Type"],
        ports: ["Protocol", "Port", "Service Name", "Port Name"],
        rulesFW: ["Demandeur CDP", "Demandeur Archi", "Type flux", "Prod/HP", "Env.", "In/Out", "Description", "Source Nom", "Source IP", "Destination Nom", "Destination IP", "Proto Nom", "Proto/Port", "Avis SSI", "Commentaire SSI", "Etat", "ID (Nom) de la Règle", "Date implémentation /Révision", "Opérateur"],
        objectsFW: ["Group Name", "Object Name", "IP", "Type"],
        portsFW: ["Protocol", "Port", "Service Name", "Port Name"],
    };

    Object.entries(headers).forEach(([key, value], index) => {
        value.forEach((header, colIndex) => {
            excel.set(index, colIndex, 0, header, formatHeader);
            excel.set(index, colIndex, undefined, "auto");
        });
    });
}
setHeaders();

// permet de créer une clé unique pour chaque objet en fonction de son groupe, nom, ip et type
function getKeyFromObject(obj) {
    return `${obj.group}:${obj.name}:${obj.ip}:${obj.type}`;
}

function handleFlow(element) {
    let ip_tab = [];
    let names_tab = [];
    let NodeFromGroup = [];
    let groupName = [];

    switch (element.attr('type')) {
        case "technology-interface":
            ip_tab = element.attr('name');
            let Names_tab_from_interface = getElementsFromRelationship(compositionRelationship,"target", "node", element[0].concept.id, "source");
            if (Names_tab_from_interface.length == 0){
                // VIP or LB
                names_tab.push(ip_tab.split("=")[0]); //names_tab.push(element.prop("Name", false));
                ip_tab = ip_tab.split("=")[1]; //ip_tab= element.prop("IP address", false);
                
            }else{
                for (var i = 0; i < Names_tab_from_interface.length; i++) {
                    if (getElementsFromRelationship(compositionRelationship,"source", "technology-interface", Names_tab_from_interface[i].attr('id'), "target").length > 1){
                        // Multiple IP for the same node
                        names_tab.push(Names_tab_from_interface[i].attr('name')+"-"+ip_tab);
                    }else{
                        names_tab.push(Names_tab_from_interface[i].attr('name'));       
                    }
                }
            }
            object = {group:"",name: names_tab, ip: ip_tab, type: "Host"};
            uniqueObject.set(getKeyFromObject(object), object);

            break;
        case "grouping":
            NodeFromGroup.push(getElementsFromRelationship(aggregationRelationship,"source", "node", element[0].concept.id, "target"));  
            NodeFromGroup.push(getElementsFromRelationship(compositionRelationship,"source", "grouping", element[0].concept.id, "target"));

            NodeFromGroup.forEach(function(nodes){
                nodes.forEach(function(node){
                    if (node.attr('type') == "node"){
                        let target = handleFlow(node) 
                        for (var i = 0; i < target.names_tab.length; i++) {
                            names_tab.push(target.names_tab[i]);
                            ip_tab.push(target.ip_tab[i]);
                        }
                    }
                    // si le noeud est un groupe, on rappelle la fonction handleFlow pour traiter les noeuds du groupe et les ajouter à la liste le groupe parent et enfant
                    else if (node.attr('type') == "grouping"){
                        let groupIds = getElementsFromRelationship(compositionRelationship,"target", "grouping", node[0].concept.id, "source");
                        for (var i = 0; i < groupIds.length; i++) {
                            groupName.push(groupIds[i].attr('name'));
                        }
                        object = {group:groupName,name: node.attr('name'), ip: "", type: "Group"};
                        uniqueObject.set(getKeyFromObject(object), object);
                        handleFlow(node);
                    }
                });
            });

            break;
        case "node": 
            // regarder si le noeud à plusieurs IP et les ajouter à la liste
            let sourceIds = getElementsFromRelationship(compositionRelationship,"source", "technology-interface", element[0].concept.id, "target");
            for (var i = 0; i < sourceIds.length; i++) {
                ip_tab.push(sourceIds[i].attr('name'));
            }
            // regarder si le noeud est dans un groupe et ajouter le nom du groupe à la liste
            let groupIds = getElementsFromRelationship(aggregationRelationship,"target", "grouping", element[0].concept.id, "source");
            for (var i = 0; i < groupIds.length; i++) {
                groupName.push(groupIds[i].attr('name'));
            }

            ip_tab.forEach(function(ip){
                if (ip_tab.length > 1){
                    // Multiple IP from node for the same node
                    names_tab.push(element.attr('name')+"-"+ip);
                    object = {group:groupName,name: element.attr('name')+"-"+ip, ip: ip, type: "Host"};
                    uniqueObject.set(getKeyFromObject(object), object);

                }else{
                    names_tab.push(element.attr('name'));
                    object = {group:groupName,name: element.attr('name'), ip: ip, type: "Host"};
                    uniqueObject.set(getKeyFromObject(object), object);
                }
            });
            
            break;
        case "communication-network":
            names_tab.push(element.attr('name'));
            ip_tab = element.prop("Network", true);
            ip_tab.forEach(function(ip){
                object = {group:"",name: names_tab, ip: ip, type: "Network"};
                uniqueObject.set(getKeyFromObject(object), object);
            });

            break;
        default:
            console.log("Unhandled source type: " + sourceType);
            break;
    }
    return { names_tab, ip_tab };
}

function getElementsFromRelationship(relation_type,relation_check, element_type, element_check, element_return){
    var element = [];
    relation_type.each(function(relation_type) {
        if (relation_type.concept[relation_check].id == element_check && $("#"+relation_type.concept[element_return].id).attr('type') == element_type) { // if target of the composition-relationship is the source of the flow-relationship
            element.push($("#"+relation_type.concept[element_return].id));
        }       
    }); 
    return element;
}

function cleanAndJoin(input) {
    if (Array.isArray(input)) {
        return input.map(item => String(item).trim()).join('\n');
    }
    return String(input).trim();
}

function addElementInExcel(sheet, column, row, value, style = null) {
    if (style) {
        excel.set(sheet, column, row, value, style);
    } else {
        excel.set(sheet, column, row, value);
    }
}

function populateExcelRow(sheet, startColumn, row, data) {
    data.forEach((value, index) => {
        addElementInExcel(sheet, startColumn + index, row, value);
    });
}

// Prepare and populate data OBJECTS and PORTS
function prepareAndPopulateData(sheet,item, type, rowStart) {
    let rowData;
    
    if (type === 'object') {
        // get map value
        rowData = [cleanAndJoin(item.group), cleanAndJoin(item.name),cleanAndJoin(item.ip),cleanAndJoin(item.type)];

    } else if (type === 'port') {
        let parts = item.split("/").map(cleanAndJoin);

        let serviceName = serviceMap[parts[1]] || 'Unknown';
        rowData = [parts[0], parts[1], serviceName, item];
    }

    populateExcelRow(sheet, 0, rowStart, rowData);
}

// Helper function to process and retrieve data from flow relationships
function processFlowRelationship(flowRelationship) {
    const source = handleFlow($("#" + flowRelationship.concept.source.id));
    const target = handleFlow($("#" + flowRelationship.concept.target.id));
    
    const ports = flowRelationship.prop("port", true);
    const serviceName = ports.map(port => {
        const parts = port.split("/").map(cleanAndJoin);
        return serviceMap[parts[1]] || 'Unknown';
    });

    return rowData = [
        ...new Array(6).fill(""),
        cleanAndJoin(flowRelationship.concept.documentation),
        cleanAndJoin(source.names_tab),
        cleanAndJoin(source.ip_tab),
        cleanAndJoin(target.names_tab),
        cleanAndJoin(target.ip_tab),
        cleanAndJoin(serviceName),
        cleanAndJoin(ports),
        ...new Array(9).fill(""),
    ];

}

// Process each flow relationship
flowRelationship.each(function (flowRelationship) {
    const rowData = processFlowRelationship(flowRelationship);

    // Populate the main Excel sheet
    populateExcelRow(0, 0, currentRow, rowData);
    currentRow++;

    // Add unique ports
    flowRelationship.prop("port", true).forEach(port => uniquePorts.add(port));

});

// Populate data for unique objects and ports in dedicated sheets
uniqueObject.forEach((object, index) => {
    prepareAndPopulateData(1, object, 'object', currentRowObject++);
});

uniquePorts.forEach((port, index) => {
    prepareAndPopulateData(2, port, 'port', currentRowPort++);
});


currentRow = 1;
currentRowObject = 1;
currentRowPort = 1;
uniqueObject = new Map();
uniquePorts = new Set(); // Initialise un Set vide pour collecter les ports uniques

// Process each flow relationship
flowRelationship.each(function(flowRelationship) {
    if (flowRelationship.prop("FW", false) == "true") {

        const rowData = processFlowRelationship(flowRelationship);

        // Populate the main Excel sheet
        populateExcelRow(3, 0, currentRow, rowData);
        currentRow++;
    
        // Add unique ports
        flowRelationship.prop("port", true).forEach(port => uniquePorts.add(port));

    }
});

// Populate data for unique objects and ports in dedicated sheets
uniqueObject.forEach((object, index) => {
    prepareAndPopulateData(4, object, 'object', currentRowObject++);
});

uniquePorts.forEach((port, index) => {
    prepareAndPopulateData(5, port, 'port', currentRowPort++);
});


excel.generate(exportFile);
console.log("> Export done");

