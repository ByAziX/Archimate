/*
 * Statistics
 * 
 * Show some stats in a message alert box
 * 
 * (c) 2024 Azix
 * 
 * This work is licensed under the HUMANS Licence described below.
 * 
 * The HUMANS (Help Us Make Archi Noteworthy & Sustainable) licence goal is to bring happiness
 * to both Archi users and developers. This means that we would like users of
 * jArchi to donate something and get this useful script as a gift in return (and feel great!).
 *
 * The only restrictions that apply are:
 *  - You can't redistribute this script.
 *  - You can't use this script for commercial purposes unless you obtained it from the official Archi distribution channels.
 * 
 */

const serviceMap = {
    '443': 'HTTPS',
    '80': 'HTTP',
    '22': 'SSH',
    '21': 'FTP',
    '23': 'Telnet',
    '25': 'SMTP',
    '110': 'POP3',
    '143': 'IMAP',
    '389': 'LDAP',
    '636': 'LDAPS',
    '53': 'DNS',
    '123': 'NTP',
    '161': 'SNMP',
  };

console.show();
console.clear();
console.log("----------GET OBJECT NODE FROM MODEL-!!!!!!!!!!!!!!!!!!!!------------");
var nodes = $("node");
//console.log(nodes);

console.log("----------GET VIEW-!!!!!!!!!!!!!!!!!!!!------------");
var view = $(".5-Prod").first(); // Get view from its name (pick the first one if multiple views share the same name)
console.log($(view).filter("name")) // Get the name of the view
var flowRelationship = $(view).find("flow-relationship"); // Build a collection containing the view, and then get all flow-relationship in this view.
var compositionRelationship = $(view).find("composition-relationship"); // Build a collection containing the composition-relationship, and then get all flow-relationship in this view.
var aggregationRelationship = $(view).find("aggregation-relationship"); // Build a collection containing the aggregation-relationship, and then get all flow-relationship in this view.
var defaultFileName = model.name ? model.name + ".xlsx" : "Exported Model.xlsx"; // Default file name
var exportFile = window.promptSaveFile({ title: "Export to Excel", filterExtensions: [ "*.xlsx" ], fileName: defaultFileName } );
let current_row = 1, current_row_object = 1, current_row_port = 1, current_row_fw = 1;
let uniqueObject = new Map();
let uniquePorts = new Set(); // Initialise un Set vide pour collecter les ports uniques
if(exportFile == null) {
    console.log("> Export cancelled");
    exit();
}
console.log("> Starting Excel Export");
// Load MyExcel and JSZip JS files
load(__DIR__ + "lib/jszip-101.js");
load(__DIR__ + "lib/myexcel.js");
// Create a new Excel file with a default font and colour
var excel = $JExcel.new("Calibri 12 #333333");
var sheet2 = excel.addSheet('Objects');
var sheet3 = excel.addSheet('Ports');
var sheet4 = excel.addSheet('FW Rules');
var formatHeader = excel.addStyle({ border: "none,none,none,thin #333333", font: "Calibri 12 #1B2A41 B", fill: "#f3f3f3" });
function setHeaders() {
    const headers = {
        rules: ["Demandeur CDP", "Demandeur Archi", "Type flux", "Prod/HP", "Env.", "In/Out", "Description", "Source Nom", "Source IP", "Destination Nom", "Destination IP", "Proto Nom", "Proto/Port", "Avis SSI", "Commentaire SSI", "Etat", "ID (Nom) de la Règle", "Date implémentation /Révision", "Opérateur"],
        objects: ["Group Name", "Object Name", "IP", "Type"],
        ports: ["Protocol", "Port", "Service Name", "Port Name"],
        rulesFW: ["Demandeur CDP", "Demandeur Archi", "Type flux", "Prod/HP", "Env.", "In/Out", "Description", "Source Nom", "Source IP", "Destination Nom", "Destination IP", "Proto Nom", "Proto/Port", "Avis SSI", "Commentaire SSI", "Etat", "ID (Nom) de la Règle", "Date implémentation /Révision", "Opérateur"],
    };

    Object.entries(headers).forEach(([key, value], index) => {
        value.forEach((header, colIndex) => {
            excel.set(index, colIndex, 0, header, formatHeader);
            excel.set(index, colIndex, undefined, "auto");
        });
    });
}
setHeaders();

// permet de créer une clé unique pour chaque objet en fonction de son groupe, nom, ip et type
function getKeyFromObject(obj) {
    return `${obj.group}:${obj.name}:${obj.ip}:${obj.type}`;
}

function handleFlow(element) {
    var IPs = [];
    var Names = [];
    var NodeFromGroup = [];

    switch (element.attr('type')) {
        case "technology-interface":
            IPs = element.attr('name');
            let Names_tab = get_element_from_relation(compositionRelationship,"target", "node", element[0].concept.id, "source");
            if (Names_tab.length == 0){
                // VIP or LB
                Names.push(IPs.split("=")[0]);
                IPs = IPs.split("=")[1];
            }else{
                for (var i = 0; i < Names_tab.length; i++) {
                    if (get_element_from_relation(compositionRelationship,"source", "technology-interface", Names_tab[i].attr('id'), "target").length > 1){
                        // Multiple IP for the same node
                        Names.push(Names_tab[i].attr('name')+"-"+IPs);
                    }else{
                        Names.push(Names_tab[i].attr('name'));       
                    }
                }
            }
            object = {group:"",name: Names, ip: IPs, type: "Host"};
            uniqueObject.set(getKeyFromObject(object), object);

            break;
        case "grouping":
            NodeFromGroup.push(get_element_from_relation(aggregationRelationship,"source", "node", element[0].concept.id, "target"));  
            NodeFromGroup.push(get_element_from_relation(compositionRelationship,"source", "grouping", element[0].concept.id, "target"));

            NodeFromGroup.forEach(function(nodes){
                nodes.forEach(function(node){
                    if (node.attr('type') == "node"){
                        let target = handleFlow(node) 
                        for (var i = 0; i < target.Names.length; i++) {
                            Names.push(target.Names[i]);
                            IPs.push(target.IPs[i]);
                        }
                    }
                    // si le noeud est un groupe, on rappelle la fonction handleFlow pour traiter les noeuds du groupe et les ajouter à la liste le groupe parent et enfant
                    else if (node.attr('type') == "grouping"){
                        let groupName = [];
                        let groupIds = get_element_from_relation(compositionRelationship,"target", "grouping", node[0].concept.id, "source");
                        for (var i = 0; i < groupIds.length; i++) {
                            groupName.push(groupIds[i].attr('name'));
                        }
                        object = {group:groupName,name: node.attr('name'), ip: "", type: "Group"};
                        uniqueObject.set(getKeyFromObject(object), object);
                        handleFlow(node);
                    }
                });
            });

            break;
        case "node": 

            // regarder si le noeud à plusieurs IP et les ajouter à la liste
            let sourceIds = get_element_from_relation(compositionRelationship,"source", "technology-interface", element[0].concept.id, "target");
            for (var i = 0; i < sourceIds.length; i++) {
                IPs.push(sourceIds[i].attr('name'));
            }
            
            // regarder si le noeud est dans un groupe et ajouter le nom du groupe à la liste
            let groupName = [];
            let groupIds = get_element_from_relation(aggregationRelationship,"target", "grouping", element[0].concept.id, "source");
            for (var i = 0; i < groupIds.length; i++) {
                groupName.push(groupIds[i].attr('name'));
            }

            IPs.forEach(function(ip){
                if (IPs.length > 1){
                    // Multiple IP from node for the same node
                    Names.push(element.attr('name')+"-"+ip);
                    object = {group:groupName,name: element.attr('name')+"-"+ip, ip: ip, type: "Host"};
                    uniqueObject.set(getKeyFromObject(object), object);

                }else{
                    Names.push(element.attr('name'));
                    object = {group:groupName,name: element.attr('name'), ip: ip, type: "Host"};
                    uniqueObject.set(getKeyFromObject(object), object);
                }
            });
            
            break;
        case "communication-network":
            Names.push(element.attr('name'));
            IPs = element.prop("Network", true);
            IPs.forEach(function(ip){
                object = {group:"",name: Names, ip: ip, type: "Network"};
                uniqueObject.set(getKeyFromObject(object), object);
            });

            break;
        default:
            console.log("Unhandled source type: " + sourceType);
            break;
    }
    return { Names, IPs };
}

function get_element_from_relation(relation_type,relation_check, element_type, element_check, element_return){
    var element = [];
    relation_type.each(function(relation_type) {
        if (relation_type.concept[relation_check].id == element_check && $("#"+relation_type.concept[element_return].id).attr('type') == element_type) { // if target of the composition-relationship is the source of the flow-relationship
            element.push($("#"+relation_type.concept[element_return].id));
        }       
    }); 
    return element;
}

function cleanAndJoin(input) {
    if (Array.isArray(input)) {
        return input.map(item => String(item).trim()).join('\n');
    }
    return String(input).trim();
}

function addElementInExcel(sheet, column, row, value, style = null) {
    if (style) {
        excel.set(sheet, column, row, value, style);
    } else {
        excel.set(sheet, column, row, value);
    }
}

function populateExcelRow(sheet, startColumn, row, data) {
    data.forEach((value, index) => {
        addElementInExcel(sheet, startColumn + index, row, value);
    });
}

flowRelationship.each(function(flowRelationship) {
    
    source = handleFlow($("#" +flowRelationship.concept["source"].id))
    target = handleFlow($("#" +flowRelationship.concept.target.id))

    let serviceName = []
    flowRelationship.prop("port", true).forEach(function(port) {
        let parts = port.split("/").map(cleanAndJoin);
        serviceName.push(serviceMap[parts[1]] || 'Unknown');
    });

    const rowData = [
        "",
        "",
        "",
        "",
        "",
        "",
        cleanAndJoin(flowRelationship.concept.documentation),
        cleanAndJoin(source.Names),
        cleanAndJoin(source.IPs),
        cleanAndJoin(target.Names),
        cleanAndJoin(target.IPs),
        cleanAndJoin(serviceName),
        cleanAndJoin(flowRelationship.prop("port", true)),
        "",
        "",
        "",
        "",
        "",
        "",
    ];
    populateExcelRow(0, 0, current_row, rowData);
    current_row++;
    // Ajoute les règles de pare-feu à une feuille distincte
    if (flowRelationship.prop("FW", false) == "true") {
        populateExcelRow(3, 0, current_row_fw, rowData);
        current_row_fw++;
    }

    // Ajoute les ports uniques à un Set
    flowRelationship.prop("port", true).forEach(function(port) {
        uniquePorts.add(port);
    });
});

// Prepare and populate data OBJECTS and PORTS
function prepareAndPopulateData(item, type, rowStart) {
    let rowData;
    
    if (type === 'object') {
        // get map value
        rowData = [cleanAndJoin(item.group), cleanAndJoin(item.name),cleanAndJoin(item.ip),cleanAndJoin(item.type)];

    } else if (type === 'port') {
        let parts = item.split("/").map(cleanAndJoin);

        let serviceName = serviceMap[parts[1]] || 'Unknown';
        rowData = [parts[0], parts[1], serviceName, item];
    }

    populateExcelRow(type === 'object' ? 1 : 2, 0, rowStart, rowData);
}

uniqueObject.forEach(object => {
    prepareAndPopulateData(object, 'object', current_row_object++);
});

uniquePorts.forEach(port => {
    prepareAndPopulateData(port, 'port', current_row_port++);
});

excel.generate(exportFile);
console.log("> Export done");


