/*
 * Statistics
 * 
 * Show some stats in a message alert box
 * 
 * (c) 2024 MILLET Hugo
 * 
 * This work is licensed under the HUMANS Licence described below.
 * 
 * The HUMANS (Help Us Make Archi Noteworthy & Sustainable) licence goal is to bring happiness
 * to both Archi users and developers. This means that we would like users of
 * jArchi to donate something and get this useful script as a gift in return (and feel great!).
 *
 * The only restrictions that apply are:
 *  - You can't redistribute this script.
 *  - You can't use this script for commercial purposes unless you obtained it from the official Archi distribution channels.
 * 
 */


const serviceMap = {
    '443': 'HTTPS',
    '80': 'HTTP',
    '22': 'SSH',
    '21': 'FTP',
    '23': 'Telnet',
    '25': 'SMTP',
    '110': 'POP3',
    '143': 'IMAP',
    '389': 'LDAP',
    '636': 'LDAPS',
    '53': 'DNS',
    '123': 'NTP',
    '161': 'SNMP',
  };

console.show();
console.clear();
console.log("----------GET OBJECT NODE FROM MODEL-!!!!!!!!!!!!!!!!!!!!------------");
var nodes = $("node");
//console.log(nodes);

console.log("----------GET VIEW-!!!!!!!!!!!!!!!!!!!!------------");
var view = $(".5-Prod").first(); // Get view from its name (pick the first one if multiple views share the same name)
console.log($(view).filter("name")) // Get the name of the view
var flowRelationship = $(view).find("flow-relationship"); // Build a collection containing the view, and then get all flow-relationship in this view.
var compositionRelationship = $(view).find("composition-relationship"); // Build a collection containing the composition-relationship, and then get all flow-relationship in this view.
var aggregationRelationship = $(view).find("aggregation-relationship"); // Build a collection containing the aggregation-relationship, and then get all flow-relationship in this view.

// Open a dialog to let the user choose where to save the generated file
var defaultFileName = model.name ? model.name + ".xlsx" : "Exported Model.xlsx"; // Default file name
var exportFile = window.promptSaveFile({ title: "Export to Excel", filterExtensions: [ "*.xlsx" ], fileName: defaultFileName } );

var current_row = 1;
var current_row_fw = 1;

uniqueObject = new Set(); // Initialise un Set vide pour collecter les object uniques
uniquePorts = new Set(); // Initialise un Set vide pour collecter les ports uniques


// User cancelled
if(exportFile == null) {
    console.log("> Export cancelled");
    exit();
}

console.log("> Starting Excel Export");

// Load MyExcel and JSZip JS files
load(__DIR__ + "lib/jszip-101.js");
load(__DIR__ + "lib/myexcel.js");

// Create a new Excel file with a default font and colour
var excel = $JExcel.new("Calibri 12 #333333");


var sheet2 = excel.addSheet('Objects');
var sheet3 = excel.addSheet('Ports');
var sheet4 = excel.addSheet('FW Rules');

// Set up some headers
var headers = [
    "RuleName",
    "Source Name",
    "Source IP",
    "Target Name",
    "Target IP",
    "Port",
    "Documentation"

];

// Format the header with a style
var formatHeader = excel.addStyle ({
    fill: "#dddddd",
	border: "thin, thin, thin, thin #555555",
	font: "Arial 12 #000000 B",
});

set_header(0, headers, formatHeader);
set_header(1, ["Group Name", "Object Name", "IP", "Type"], formatHeader);
set_header(2, ["Protocol", "Port", "Service Name","Port Name"], formatHeader);
set_header(3, headers, formatHeader);

function set_header(sheet_number, headers, formatHeader){
    for(var i = 0; i < headers.length; i++) {
        excel.set(sheet_number, i, 0, headers[i], formatHeader);
        excel.set(sheet_number, i, undefined, "auto"); // column width is auto
    }
}


var current_row_object = 1;

// Fonction pour récupérer et traiter les informations de la source selon le type
function handleFlow(sourceId) {
    
    var sourceType = sourceId.attr('type');
    var sourceName = sourceId.attr('name');
    var sourceIPs = [];
    var sourceNames = [];
    var NodeFromGroup = [];
    var sourceNames_tab = [];


    print("sourceType: "+sourceType);
    print("sourceName: "+sourceName);

    switch (sourceType) {
        case "technology-interface":

            sourceIPs = sourceId.attr('name'); // get ip of the source
            sourceNames_tab = get_node_name_from_interface(sourceId[0].concept.id);
            if (sourceNames_tab.length == 0){
                console.log("VIP or LB")
                sourceNames.push(sourceIPs.split("=")[0]);
                sourceIPs = sourceIPs.split("=")[1];


            }else{
                for (var i = 0; i < sourceNames_tab.length; i++) {
                    if (get_interface_ip_from_node(sourceNames_tab[i].attr('id')).length > 1){
                        console.log("Multiple IP for the same node")
                        sourceNames.push(sourceNames_tab[i].attr('name')+"-"+sourceIPs);
                    }else{
                            sourceNames.push(sourceNames_tab[i].attr('name'));
                    
                    }
                }
            }

            console.log(sourceNames+"_"+sourceIPs+'_Host')
            uniqueObject.add(sourceNames+"_"+sourceIPs+'_Host');
            
            

            break;
        case "grouping":

            NodeFromGroup.push(get_node_from_group(sourceId[0].concept.id));            
            NodeFromGroup.forEach(function(nodes){
                nodes.forEach(function(node){
                    target = handleFlow(node) 
                    sourceIPs = target.sourceIPs;
                    sourceNames = target.sourceNames;
                });
            });

            break;
        case "node":
            sourceIPs = get_interface_ip_from_node(sourceId[0].concept.id);

            sourceIPs.forEach(function(ip){
                if (sourceIPs.length > 1){
                    console.log("Multiple IP from node for the same node")
                    sourceNames.push(sourceId.attr('name')+"-"+ip);
                    uniqueObject.add(sourceId.attr('name')+"-"+ip+"_"+ip+'_Host');

                }else{
                    sourceNames.push(sourceId.attr('name'));
                    uniqueObject.add(sourceNames+"_"+ip+'_Host');

                }
                console.log(sourceNames+"_"+ip+'_Host')

            });
            
            break;
        default:
            console.log("Unhandled source type: " + sourceType);
            break;
    }

    return { sourceNames, sourceIPs };
}

function get_node_name_from_interface(interface_id){
    var node_name = [];
    
    compositionRelationship.each(function(compositionRelationship) { // get all composition-relationship
        if (compositionRelationship.concept.target.id == interface_id && $("#"+compositionRelationship.concept.source.id).attr("type") == "node") { // if target of the composition-relationship is the source of the flow-relationship
            node_name.push($("#"+compositionRelationship.concept.source.id));
        }       
    }
    );    
    return node_name;
}

function get_interface_ip_from_node(node_id){
    var interface_ip = [];
    compositionRelationship.each(function(compositionRelationship) { // get all composition-relationship
        if (compositionRelationship.concept.source.id == node_id) { // if target of the composition-relationship is the source of the flow-relationship
            interface_ip.push($("#"+compositionRelationship.concept.target.id).attr('name'));
        }       
    }
    );    
    return interface_ip;
}

function get_node_from_group(group_id){
    var node = [];
    aggregationRelationship.each(function(aggregationRelationship) { // get all composition-relationship
        if (aggregationRelationship.concept.source.id == group_id) { // if target of the composition-relationship is the source of the flow-relationship
            if ($("#"+aggregationRelationship.concept.target.id).attr('type') == "node"){
                node.push($("#"+aggregationRelationship.concept.target.id));
            }
        }       
    }
    );    
    return node;    
}

function cleanAndJoin(input) {
    if (Array.isArray(input)) {
        // S'assure que chaque élément est converti en chaîne avant de le nettoyer
        return input.map(item => String(item).trim()).join('\n');
    }
    return String(input).trim();  // Convertit en chaîne puis applique trim
}

function cleanString(input) {
    return input.trim();
}


function addElementInExcel(sheet, column, row, value, style = null) {
    if (style) {
        excel.set(sheet, column, row, value, style);
    } else {
        excel.set(sheet, column, row, value);
    }
}

function populateExcelRow(sheet, startColumn, row, data) {
    data.forEach((value, index) => {
        addElementInExcel(sheet, startColumn + index, row, value);
    });
}

flowRelationship.each(function(flowRelationship) { // Note: 'node' is a Visual Object
    
    source = handleFlow($("#" +flowRelationship.concept.source.id))
    target = handleFlow($("#" +flowRelationship.concept.target.id))

    console.log("\n")

    const rowData = [
        cleanAndJoin(flowRelationship.concept.name),
        cleanAndJoin(source.sourceNames),
        cleanAndJoin(source.sourceIPs),
        cleanAndJoin(target.sourceNames),
        cleanAndJoin(target.sourceIPs),
        cleanAndJoin(flowRelationship.prop("port", true)),
        cleanAndJoin(flowRelationship.concept.documentation)
    ];

    // Populate the row in the Excel sheet
    populateExcelRow(0, 0, current_row, rowData);
    current_row++;

    console.log("\n");
    console.log(flowRelationship.prop("FW", false));
    if (flowRelationship.prop("FW", false) == "true") {
       
        populateExcelRow(3, 0, current_row_fw, rowData);

        current_row_fw++;
    } else {
        console.log("propName is false");
    }
}
);


uniqueObject.forEach(function(object) {
    var objectParts = object.split("_").map(cleanString); // Nettoie chaque partie après la division
    const rowData = [
        "",
        objectParts[0],
        objectParts[1],
        objectParts[2],
    ];
    populateExcelRow(1, 0, current_row_object, rowData);
    current_row_object++;
});


current_row = 1;

flowRelationship.each(function(flowRelationship) {
    
    var ports = flowRelationship.prop("port", true);

    ports.forEach(function(port) {
        uniquePorts.add(port);
    });
});

// Après avoir collecté tous les ports uniques, itère sur le Set uniquePorts
uniquePorts.forEach(function(port) {
    // Séparation et nettoyage des parties du port
    var parts = port.split("_").map(cleanString);
    var portNumber = parts[0];
    var protocol = parts[1];

    var serviceName = serviceMap[protocol] || 'Unknown';
    
    const rowData = [
        portNumber,
        protocol,
        serviceName,
        port
    ];

    populateExcelRow(2, 0, current_row, rowData);
    current_row++;
});

excel.generate(exportFile);
console.log("> Export done");
