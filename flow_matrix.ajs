/*
 * Statistics
 * 
 * Show some stats in a message alert box
 * 
 * (c) 2024 Azix
 * 
 * This work is licensed under the HUMANS Licence described below.
 * 
 * The HUMANS (Help Us Make Archi Noteworthy & Sustainable) licence goal is to bring happiness
 * to both Archi users and developers. This means that we would like users of
 * jArchi to donate something and get this useful script as a gift in return (and feel great!).
 *
 * The only restrictions that apply are:
 *  - You can't redistribute this script.
 *  - You can't use this script for commercial purposes unless you obtained it from the official Archi distribution channels.
 * 
 */

load(__DIR__ + "lib/jszip-101.js");
load(__DIR__ + "lib/myexcel.js");


const serviceMap = {
    '443': 'HTTPS',
    '80': 'HTTP',
    '22': 'SSH',
    '21': 'FTP',
    '23': 'Telnet',
    '25': 'SMTP',
    '110': 'POP3',
    '143': 'IMAP',
    '389': 'LDAP',
    '636': 'LDAPS',
    '53': 'DNS',
    '123': 'NTP',
    '161': 'SNMP',
};

const SHEET_NAMES = {
    rules: 'Rules',
    objects: 'Objects',
    ports: 'Ports',
    fwRules: 'FW Rules',
    fwObjects: 'FW Objects',
    fwPorts: 'FW Ports'
};


const HEADERS = {
    rules: ["Demandeur CDP", "Demandeur Archi", "Type flux", "Prod/HP", "Env.", "In/Out", "Description", "Source Nom", "Source IP", "Destination Nom", "Destination IP", "Proto Nom", "Proto/Port", "Avis SSI", "Commentaire SSI", "Etat", "ID (Nom) de la Règle", "Date implémentation /Révision", "Opérateur"],
    objects: ["Group Name", "Object Name", "IP", "Type"],
    ports: ["Protocol", "Port", "Service Name", "Port Name"],
    fwRules: ["Demandeur CDP", "Demandeur Archi", "Type flux", "Prod/HP", "Env.", "In/Out", "Description", "Source Nom", "Source IP", "Destination Nom", "Destination IP", "Proto Nom", "Proto/Port", "Avis SSI", "Commentaire SSI", "Etat", "ID (Nom) de la Règle", "Date implémentation /Révision", "Opérateur"],
    fwObjects: ["Group Name", "Object Name", "IP", "Type"],
    fwPorts: ["Protocol", "Port", "Service Name", "Port Name"],
};

const DEFAULT_STYLE = { border: "none,none,none,thin #333333", font: "Calibri 12 #1B2A41 B", fill: "#f3f3f3" };


console.show();
console.clear();
var nodes = $("node");
var view = selection.parents().add(selection).filter("view").first();
console.log("> Exporting view: " + $(view).attr("name"));
var flowRelationship = $(view).find("flow-relationship"); // Build a collection containing the view, and then get all flow-relationship in this view.
var compositionRelationship = $(view).find("composition-relationship"); // Build a collection containing the composition-relationship, and then get all flow-relationship in this view.
var aggregationRelationship = $(view).find("aggregation-relationship"); // Build a collection containing the aggregation-relationship, and then get all flow-relationship in this view.
var defaultFileName = model.name+"_"+$(view).attr("name") ? model.name+"_"+$(view).attr("name") + ".xlsx" : "Exported Model.xlsx"; // Default file name
var exportFile = window.promptSaveFile({ title: "Export to Excel", filterExtensions: [ "*.xlsx" ], fileName: defaultFileName } );
let currentRow = 1, currentRowObject = 1, currentRowPort = 1;
let uniqueObject = new Map();
let uniquePorts = new Set(); // Initialise un Set vide pour collecter les ports uniques
let uniqueIP = new Set(); // Initialise un Set vide pour collecter les IP uniques
let ip_set = new Set();

if(exportFile == null) {
    console.log("> Export cancelled");
    exit();
}

console.log("> Starting Excel Export");
function createSheetsAndHeaders(excel, sheetNames, headers, defaultStyle) {
    const formatHeader = excel.addStyle(defaultStyle);
    const sheets = {};

    Object.keys(sheetNames).forEach((key) => {
        if (!headers[key]) {
            console.error(`No headers found for key: ${key}`);
            return; // Skip creating this sheet if headers are not found
        }
        const sheet = excel.addSheet(sheetNames[key]);
    
        sheets[key] = sheet;
        setHeaders(sheet, headers[key], formatHeader);
    });

    return sheets;
}

function setHeaders(sheet, headers, style) {
    if (!headers) {
        console.error('Headers are undefined, cannot set headers in the sheet.');
        return;
    }
    headers.forEach((header, index) => {
        excel.set(sheet, index, 0, header, style);
    });
}

// permet de créer une clé unique pour chaque objet en fonction de son groupe, nom, ip et type
function getKeyFromObject(obj) {
    return `${obj.group}:${obj.name}:${obj.ip}:${obj.type}`;
}

function handleFlow(element) {
    let ip_from_interface = [];
    let name_from_node = [];
    let name_from_group = [];
    let node_from_group = [];
    let group_from_group = [];

    switch (element.attr('type')) {
        case "technology-interface":
            ip_from_interface = element.prop("IP address", false);
            let check_name_from_node = getElementsFromRelationship([compositionRelationship,aggregationRelationship],"target", "node", element[0].concept.id, "source");
            if (check_name_from_node.length == 0){
                // VIP or LB
                name_from_node.push(element.prop("Name", false));
                ip_from_interface = element.prop("IP address", false);
                
            }else{
                for (var i = 0; i < check_name_from_node.length; i++) {
                    if (getElementsFromRelationship([compositionRelationship,aggregationRelationship],"source", "technology-interface", check_name_from_node[i].attr('id'), "target").length > 1){
                        // Multiple IP for the same node, node is unique in fw rules so we add the IP to the name
                        name_from_node.push(check_name_from_node[i].attr('name')+"-"+ip_from_interface);
                    }else{
                        name_from_node.push(check_name_from_node[i].attr('name'));       
                    }
                }
            }
            object = {group:"",name: name_from_node, ip: ip_from_interface, type: "Host"};
            uniqueObject.set(getKeyFromObject(object), object);

            break;
        case "grouping":
            console.log("Parents "+element[0].concept.name);

            node_from_group.push(getElementsFromRelationship([aggregationRelationship,compositionRelationship],"source", "node", element[0].concept.id, "target"));  
            node_from_group.forEach(function(nodes){
                nodes.forEach(function(node){
                    if (node.attr('type') == "node"){
                        let target = handleFlow(node) 
                        for (var i = 0; i < target.name_from_node.length; i++) {
                            name_from_node.push(target.name_from_node[i]);
                            ip_from_interface.push(target.ip_from_interface[i]);
                        }
                    }

                });
            });
            
            group_from_group.push(getElementsFromRelationship([compositionRelationship,aggregationRelationship],"source", "grouping", element[0].concept.id, "target"))
            group_from_group.forEach(function(groups){
                groups.forEach(function(group){
                    if (group.attr('type') == "grouping"){
                        console.log("Enfant "+group.attr('name'));

                        let groupIds = getElementsFromRelationship([compositionRelationship,aggregationRelationship],"target", "grouping", group[0].concept.id, "source");
                        for (var i = 0; i < groupIds.length; i++) {
                            name_from_group.push(groupIds[i].attr('name'));
                        }
                        object = {group:name_from_group,name: group.attr('name'), ip: "", type: "Group"};
                        uniqueObject.set(getKeyFromObject(object), object);
                        let target = handleFlow(group);
                        for (var i = 0; i < target.name_from_node.length; i++) {
                            name_from_node.push(target.name_from_node[i]);
                            ip_from_interface.push(target.ip_from_interface[i]);
                        }

                    }
                });
            });


            break;
        case "node": 
            // regarder si le noeud à plusieurs IP et les ajouter à la liste
            let sourceIds = getElementsFromRelationship([compositionRelationship,aggregationRelationship],"source", "technology-interface", element[0].concept.id, "target");
            for (var i = 0; i < sourceIds.length; i++) {
                ip_from_interface.push(sourceIds[i].attr("name"));
            }

            // regarder si le noeud est dans un groupe et ajouter le nom du groupe à la liste
            let groupIds = getElementsFromRelationship([aggregationRelationship,aggregationRelationship],"target", "grouping", element[0].concept.id, "source");
            for (var i = 0; i < groupIds.length; i++) {
                name_from_group.push(groupIds[i].attr('name'));
            }

            ip_from_interface.forEach(function(ip){

                if (ip_from_interface.length > 1){
                    // Multiple IP from node for the same node
                    name_from_node.push(element.attr('name')+"-"+ip);
                    object = {group:name_from_group,name: element.attr('name')+"-"+ip, ip: ip, type: "Host"};
                    uniqueObject.set(getKeyFromObject(object), object);

                }else{
                    // si element.attr('name') pas dans la liste name_from_node alors on l'ajoute
                    if (!name_from_node.includes(element.attr('name'))){
                        name_from_node.push(element.attr('name'));
                        object = {group:name_from_group,name: element.attr('name'), ip: ip, type: "Host"};
                        uniqueObject.set(getKeyFromObject(object), object);
                    }
                }
            });
            
            break;
        case "communication-network":
            name_from_node.push(element.attr('name'));
            ip_from_interface = element.prop("Network", true);
            ip_from_interface.forEach(function(ip){
                object = {group:"",name: name_from_node, ip: ip, type: "Network"};
                uniqueObject.set(getKeyFromObject(object), object);
            });

            break;
        default:
            console.log("Unhandled source type: " + sourceType);
            break;
    }
    return { name_from_node, ip_from_interface };
}

function getElementsFromRelationship(relation_types,relation_check, element_type, element_check, element_return){
    var element = [];
    relation_types.forEach(function(relation_type) {
        
        relation_type.forEach(function(relation) {
            if (relation.concept[relation_check].id == element_check && $("#"+relation.concept[element_return].id).attr('type') == element_type) { // if target of the composition-relationship is the source of the flow-relationship
                element.push($("#"+relation.concept[element_return].id));
            }       
        }); 

    });

    return element;
}

function cleanAndJoin(input) {
    if (Array.isArray(input)) {
        return input.map(item => String(item).trim()).join('\n');
    }
    return String(input).trim();
}

function addElementInExcel(sheet, column, row, value, style = null) {
    if (style) {
        excel.set(sheet, column, row, value, style);
    } else {
        excel.set(sheet, column, row, value);
    }
}

function populateExcelRow(sheet, startColumn, row, data) {
    data.forEach((value, index) => {
        addElementInExcel(sheet, startColumn + index, row, value);
    });
}

// Prepare and populate data OBJECTS and PORTS
function prepareAndPopulateData(sheet,item, type, rowStart) {
    let rowData;
    
    if (type === 'object') {
        // get map value
        rowData = [cleanAndJoin(item.group), cleanAndJoin(item.name),cleanAndJoin(item.ip),cleanAndJoin(item.type)];

    } else if (type === 'port') {
        let parts = item.split("/").map(cleanAndJoin);

        let serviceName = serviceMap[parts[1]] || 'Unknown';
        rowData = [parts[0], parts[1], serviceName, item];
    }

    populateExcelRow(sheet, 0, rowStart, rowData);
}

// Helper function to process and retrieve data from flow relationships
function processFlowRelationship(flowRelationship) {
    const source = handleFlow($("#" + flowRelationship.concept.source.id));
    const target = handleFlow($("#" + flowRelationship.concept.target.id));
    const ports = flowRelationship.prop("port", true);
    const serviceName = ports.map(port => {
        const parts = port.split("/").map(cleanAndJoin);
        return serviceMap[parts[1]] || 'Unknown';
    });

    return rowData = [
        ...new Array(6).fill(""),
        cleanAndJoin(flowRelationship.concept.documentation),
        cleanAndJoin(source.name_from_node),
        cleanAndJoin(source.ip_from_interface),
        cleanAndJoin(target.name_from_node),
        cleanAndJoin(target.ip_from_interface),
        cleanAndJoin(serviceName),
        cleanAndJoin(ports),
        ...new Array(9).fill(""),
    ];

}

function processAllFlowRelationships(sheet,flowRelationships, checkFW) {
    flowRelationships.each(flowRelationship => {
        if (!checkFW || flowRelationship.prop("FW", false) === "true") {
            const rowData = processFlowRelationship(flowRelationship);
            populateExcelRow(sheet, 0, currentRow++, rowData);
            flowRelationship.prop("port", true).forEach(port => uniquePorts.add(port));
        }
    });
}

// MAIN
const excel = $JExcel.new();
excel.removeSheet("Sheet 0");
const sheets = createSheetsAndHeaders(excel, SHEET_NAMES, HEADERS, DEFAULT_STYLE);


// Processing all relationships without the 'FW' check
processAllFlowRelationships(0,flowRelationship, false);

// Populate data for unique objects and ports in dedicated sheets
uniqueObject.forEach((object, index) => {
    prepareAndPopulateData(1, object, 'object', currentRowObject++);
});

uniquePorts.forEach((port, index) => {
    prepareAndPopulateData(2, port, 'port', currentRowPort++);
});


// Processing only those with 'FW' set to 'true' in FW Matrice

currentRow = 1, currentRowObject = 1, currentRowPort = 1;
uniqueObject = new Map();
uniquePorts = new Set(); // Initialise un Set vide pour collecter les ports uniques

// Processing only those with 'FW' set to 'true'
processAllFlowRelationships(3,flowRelationship, true);

// Populate data for unique objects and ports in dedicated sheets
uniqueObject.forEach((object, index) => {
    prepareAndPopulateData(4, object, 'object', currentRowObject++);
});

uniquePorts.forEach((port, index) => {
    prepareAndPopulateData(5, port, 'port', currentRowPort++);
});


excel.generate(exportFile);
console.log("> Export done");

