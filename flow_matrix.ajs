/*
 * Statistics
 * 
 * Show some stats in a message alert box
 * 
 * (c) 2024 MILLET Hugo
 * 
 * This work is licensed under the HUMANS Licence described below.
 * 
 * The HUMANS (Help Us Make Archi Noteworthy & Sustainable) licence goal is to bring happiness
 * to both Archi users and developers. This means that we would like users of
 * jArchi to donate something and get this useful script as a gift in return (and feel great!).
 *
 * The only restrictions that apply are:
 *  - You can't redistribute this script.
 *  - You can't use this script for commercial purposes unless you obtained it from the official Archi distribution channels.
 * 
 */

const serviceMap = {
    '443': 'HTTPS',
    '80': 'HTTP',
    '22': 'SSH',
    '21': 'FTP',
    '23': 'Telnet',
    '25': 'SMTP',
    '110': 'POP3',
    '143': 'IMAP',
    '389': 'LDAP',
    '636': 'LDAPS',
    '53': 'DNS',
    '123': 'NTP',
    '161': 'SNMP',
  };

console.show();
console.clear();
console.log("----------GET OBJECT NODE FROM MODEL-!!!!!!!!!!!!!!!!!!!!------------");
var nodes = $("node");
//console.log(nodes);

console.log("----------GET VIEW-!!!!!!!!!!!!!!!!!!!!------------");
var view = $(".5-Prod").first(); // Get view from its name (pick the first one if multiple views share the same name)
console.log($(view).filter("name")) // Get the name of the view
var flowRelationship = $(view).find("flow-relationship"); // Build a collection containing the view, and then get all flow-relationship in this view.
var compositionRelationship = $(view).find("composition-relationship"); // Build a collection containing the composition-relationship, and then get all flow-relationship in this view.
var aggregationRelationship = $(view).find("aggregation-relationship"); // Build a collection containing the aggregation-relationship, and then get all flow-relationship in this view.
var defaultFileName = model.name ? model.name + ".xlsx" : "Exported Model.xlsx"; // Default file name
var exportFile = window.promptSaveFile({ title: "Export to Excel", filterExtensions: [ "*.xlsx" ], fileName: defaultFileName } );
var current_row = 1;
var current_row_fw = 1;
var current_row_object = 1;
uniqueObject = new Set(); // Initialise un Set vide pour collecter les object uniques
uniquePorts = new Set(); // Initialise un Set vide pour collecter les ports uniques
if(exportFile == null) {
    console.log("> Export cancelled");
    exit();
}
console.log("> Starting Excel Export");
// Load MyExcel and JSZip JS files
load(__DIR__ + "lib/jszip-101.js");
load(__DIR__ + "lib/myexcel.js");
// Create a new Excel file with a default font and colour
var excel = $JExcel.new("Calibri 12 #333333");
var sheet2 = excel.addSheet('Objects');
var sheet3 = excel.addSheet('Ports');
var sheet4 = excel.addSheet('FW Rules');
var headers = [
    "RuleName",
    "Source Name",
    "Source IP",
    "Target Name",
    "Target IP",
    "Port",
    "Documentation"

];
var formatHeader = excel.addStyle ({
    fill: "#dddddd",
	border: "thin, thin, thin, thin #555555",
	font: "Arial 12 #000000 B",
});
set_header(0, headers, formatHeader);
set_header(1, ["Group Name", "Object Name", "IP", "Type"], formatHeader);
set_header(2, ["Protocol", "Port", "Service Name","Port Name"], formatHeader);
set_header(3, headers, formatHeader);

function set_header(sheet_number, headers, formatHeader){
    for(var i = 0; i < headers.length; i++) {
        excel.set(sheet_number, i, 0, headers[i], formatHeader);
        excel.set(sheet_number, i, undefined, "auto"); // column width is auto
    }
}

function handleFlow(sourceId) {
    
    var sourceType = sourceId.attr('type');
    var sourceName = sourceId.attr('name');
    var sourceIPs = [];
    var sourceNames = [];
    var NodeFromGroup = [];
    var sourceNames_tab = [];


    print("sourceType: "+sourceType);
    print("sourceName: "+sourceName);

    switch (sourceType) {
        case "technology-interface":

            sourceIPs = sourceId.attr('name');
            sourceNames_tab = get_element_from_relation(compositionRelationship,"target", "node", sourceId[0].concept.id, "source");

            if (sourceNames_tab.length == 0){
                console.log("VIP or LB")
                sourceNames.push(sourceIPs.split("=")[0]);
                sourceIPs = sourceIPs.split("=")[1];
            }else{
                for (var i = 0; i < sourceNames_tab.length; i++) {
                    if (get_element_from_relation(compositionRelationship,"source", "technology-interface", sourceNames_tab[i].attr('id'), "target").length > 1){
                        console.log("Multiple IP for the same node")
                        sourceNames.push(sourceNames_tab[i].attr('name')+"-"+sourceIPs);
                    }else{
                        sourceNames.push(sourceNames_tab[i].attr('name'));
                    
                    }
                }
            }

            console.log(sourceNames+"_"+sourceIPs+'_Host')
            uniqueObject.add(sourceNames+"_"+sourceIPs+'_Host');
            
            break;
        case "grouping":

            NodeFromGroup.push(get_element_from_relation(aggregationRelationship,"source", "node", sourceId[0].concept.id, "target"));         
            NodeFromGroup.forEach(function(nodes){
                nodes.forEach(function(node){
                    target = handleFlow(node) 
                    for (var i = 0; i < target.sourceNames.length; i++) {
                        sourceNames.push(target.sourceNames[i]);
                        sourceIPs.push(target.sourceIPs[i]);
                    }
                });
            });

            break;
        case "node":
            
            sourceIds = get_element_from_relation(compositionRelationship,"source", "technology-interface", sourceId[0].concept.id, "target");
            for (var i = 0; i < sourceIds.length; i++) {
                sourceIPs.push(sourceIds[i].attr('name'));
            }

            sourceIPs.forEach(function(ip){
                if (sourceIPs.length > 1){
                    console.log("Multiple IP from node for the same node")
                    sourceNames.push(sourceId.attr('name')+"-"+ip);
                    uniqueObject.add(sourceId.attr('name')+"-"+ip+"_"+ip+'_Host');

                }else{
                    sourceNames.push(sourceId.attr('name'));
                    uniqueObject.add(sourceNames+"_"+ip+'_Host');
                }
                console.log(sourceNames+"_"+ip+'_Host')

            });
            
            break;
        default:
            console.log("Unhandled source type: " + sourceType);
            break;
    }

    return { sourceNames, sourceIPs };
}

function get_element_from_relation(relation_type,relation_check, element_type, element_check, element_return){
    var element = [];
    relation_type.each(function(relation_type) {
        if (relation_type.concept[relation_check].id == element_check && $("#"+relation_type.concept[element_return].id).attr('type') == element_type) { // if target of the composition-relationship is the source of the flow-relationship
            element.push($("#"+relation_type.concept[element_return].id));
        }       
    }
    );    
    return element;
}

function cleanAndJoin(input) {
    if (Array.isArray(input)) {
        return input.map(item => String(item).trim()).join('\n');
    }
    return String(input).trim();
}

function cleanString(input) {
    return input.trim();
}

function addElementInExcel(sheet, column, row, value, style = null) {
    if (style) {
        excel.set(sheet, column, row, value, style);
    } else {
        excel.set(sheet, column, row, value);
    }
}

function populateExcelRow(sheet, startColumn, row, data) {
    data.forEach((value, index) => {
        addElementInExcel(sheet, startColumn + index, row, value);
    });
}

flowRelationship.each(function(flowRelationship) { // Note: 'node' is a Visual Object
    
    source = handleFlow($("#" +flowRelationship.concept["source"].id))
    target = handleFlow($("#" +flowRelationship.concept.target.id))

    console.log("\n")

    const rowData = [
        cleanAndJoin(flowRelationship.concept.name),
        cleanAndJoin(source.sourceNames),
        cleanAndJoin(source.sourceIPs),
        cleanAndJoin(target.sourceNames),
        cleanAndJoin(target.sourceIPs),
        cleanAndJoin(flowRelationship.prop("port", true)),
        cleanAndJoin(flowRelationship.concept.documentation)
    ];

    populateExcelRow(0, 0, current_row, rowData);
    current_row++;

    if (flowRelationship.prop("FW", false) == "true") {
        populateExcelRow(3, 0, current_row_fw, rowData);
        current_row_fw++;
    }


    // Ajoute les ports uniques Ã  un Set
    flowRelationship.prop("port", true).forEach(function(port) {
        uniquePorts.add(port);
    });
}
);



// Prepare and populate data OBJECTS and PORTS
function prepareAndPopulateData(item, type, rowStart) {
    let parts = item.split("_").map(cleanString);
    let rowData;
    
    if (type === 'object') {
        rowData = ["", ...parts];
    } else if (type === 'port') {
        let serviceName = serviceMap[parts[1]] || 'Unknown';
        rowData = [parts[0], parts[1], serviceName, item];
    }

    populateExcelRow(type === 'object' ? 1 : 2, 0, rowStart, rowData);
}

uniqueObject.forEach(object => {
    prepareAndPopulateData(object, 'object', current_row_object++);
});

let current_row_port = 1;
uniquePorts.forEach(port => {
    prepareAndPopulateData(port, 'port', current_row_port++);
});

excel.generate(exportFile);
console.log("> Export done");
